diff -Nrup net-snmp-5.7.2-old/agent/mibgroup/CPEUpFirmwareModule.c net-snmp-5.7.2-new/agent/mibgroup/CPEUpFirmwareModule.c
--- net-snmp-5.7.2-old/agent/mibgroup/CPEUpFirmwareModule.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.7.2-new/agent/mibgroup/CPEUpFirmwareModule.c	2014-07-10 08:44:35.828992045 -0700
@@ -0,0 +1,1504 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 17798 2009-10-27 06:44:54Z magfr $
+ * Author:Alvin ke
+ * revision: initial
+ * maily for upgrade firmware through snmp
+ * date: 2013-5-9
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "CPEUpFirmwareModule.h"
+
+static const oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};
+extern int errno;
+
+const oid cpefileUpfwStatus_oid[] = { 1,3,6,1,4,1,99000,1,600,1,3 };
+
+/** Initializes the CPEUpFirmwareModule module */
+void
+init_CPEUpFirmwareModule(void)
+{
+    const oid cpesystemstatus_oid[] = { 1,3,6,1,4,1,99000,1,600,1,1 };
+    const oid fwUpgradeFilename_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,1 };
+    const oid fwUpgradeAddress_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,2 };
+	const oid fwUpgradeProtocol_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,3 };
+    const oid fwUpgradeAction_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,4 };
+    const oid fwUpgradeStatus_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,5 };
+	const oid fwUpgradeUser_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,6 };
+	const oid fwUpgradePwd_oid[] = { 1,3,6,1,4,1,99000,1,600,1,2,7 };
+
+  DEBUGMSGTL(("CPEUpFirmwareModule", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("cpesystemstatus", handle_cpesystemstatus,
+                               cpesystemstatus_oid, OID_LENGTH(cpesystemstatus_oid),
+                               HANDLER_CAN_RONLY
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradeFilename", handle_fwUpgradeFilename,
+                               fwUpgradeFilename_oid, OID_LENGTH(fwUpgradeFilename_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradeAddress", handle_fwUpgradeAddress,
+                               fwUpgradeAddress_oid, OID_LENGTH(fwUpgradeAddress_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradePotocol", handle_fwUpgradeProtocol,
+                               fwUpgradeProtocol_oid, OID_LENGTH(fwUpgradeProtocol_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradeAction", handle_fwUpgradeAction,
+                               fwUpgradeAction_oid, OID_LENGTH(fwUpgradeAction_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradeStatus", handle_fwUpgradeStatus,
+                               fwUpgradeStatus_oid, OID_LENGTH(fwUpgradeStatus_oid),
+                               HANDLER_CAN_RONLY
+        ));
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradeUsername", handle_fwUpgradeUser,
+                               fwUpgradeUser_oid, OID_LENGTH(fwUpgradeUser_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("fwUpgradePassword", handle_fwUpgradePwd,
+                               fwUpgradePwd_oid, OID_LENGTH(fwUpgradePwd_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+}
+
+
+/*get system status
+* 0:busy,don't allow update
+* other: allow update
+* read-only
+*/
+int
+handle_cpesystemstatus(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    int ret;
+	char TmpBuf[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "status", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(TmpBuf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpesystemstatus\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get firmware name
+* 1. lenth must gt 4 and lt 128
+* 2. suffix is ".bin"
+* read-write
+*/
+int
+handle_fwUpgradeFilename(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char firmname[Tmp_Len],TmpBuf[Tmp_Len];
+	int tmplen=0,j=0;
+    memset(firmname,0,sizeof(firmname));
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "filename", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			if(strlen(TmpBuf) > 0)
+            	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,TmpBuf,strlen(TmpBuf));
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,NULL,0);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+            /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			if(requests->requestvb->val_len >= Tmp_Len || requests->requestvb->val_len <= 4)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			tmplen = requests->requestvb->val_len;
+			strncpy(firmname,requests->requestvb->val.string,tmplen);
+			firmname[tmplen] = '\0';
+			printf("%s: firmware name %s\n",__func__, firmname);
+			if(strcmp(&firmname[tmplen-4],".bin"))
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			tmplen=0;
+			for(j=0;j<strlen(firmname);j++)
+			{
+				if((int)firmname[j] < 0)
+				{
+					tmplen=1;
+					break;
+				}
+				if(firmname[j] == '^' || firmname[j] == '`' || firmname[j] == '"'
+					|| firmname[j] == '\'' || firmname[j] == '\\' || firmname[j] == '/'
+					|| firmname[j] == '|' || firmname[j] == ':' || firmname[j] == '*'
+					|| firmname[j] == '?' || firmname[j] == '<' || firmname[j] == '>'
+					|| firmname[j] == ' ')
+				{
+					tmplen=1;
+					break;
+				}
+			}
+			if(tmplen == 1)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			/* XXX: perform the value change here */
+			tmplen = requests->requestvb->val_len;
+			strncpy(firmname,requests->requestvb->val.string,tmplen);
+			firmname[tmplen] = '\0';
+			printf("%s: firmware name %s\n",__func__, firmname);
+			ezplib_replace_attr("snmpd_upgrade_rule",0,"filename",firmname);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if(strlen(TmpBuf) > 0)
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"filename",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeFilename\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get server IP Address
+* don't allow 255.255.255.255 or 0.0.0.0
+* read-write
+*/
+int
+handle_fwUpgradeAddress(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+
+	char *ipaddr,TmpBuf[Tmp_Len];
+	u_long result;
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "ipaddr", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			if(strlen(TmpBuf) > 0)
+			{
+				result=inet_addr(TmpBuf);
+            	snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&result,sizeof(result));
+			}
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,NULL,0);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			result = *(requests->requestvb->val.integer);
+			ipaddr = inet_ntoa(result);
+			if (ipaddr == NULL)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			printf("%s: result %08x, IP adrress %s\n",__func__, result,ipaddr);
+			if((strcmp(ipaddr, "255.255.255.255") == 0) || (strcmp(ipaddr, "0.0.0.0") == 0))
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			result = *(requests->requestvb->val.integer);
+			ipaddr = inet_ntoa(result);
+			printf("%s: result %08x, IP adrress %s\n",__func__, result,ipaddr);
+			ezplib_replace_attr("snmpd_upgrade_rule",0,"ipaddr",ipaddr);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			if(strlen(TmpBuf) > 0)
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"ipaddr",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeAddress\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get transfer protocol
+* it's only support tftp(0),ftp(1)
+* read-write
+*/
+int
+handle_fwUpgradeProtocol(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char TmpBuf[Tmp_Len];
+	char TmpBuf2[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	memset(TmpBuf2,0,sizeof(TmpBuf2));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "protocol", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(TmpBuf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			ret = *(requests->requestvb->val.integer);
+			printf("protocol is %d\n",ret);
+			if(ret != 1)//only support ftp
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			printf("protocol is %d\n",ret);
+			sprintf(TmpBuf2,"%d",ret);
+			ezplib_replace_attr("snmpd_upgrade_rule",0,"protocol",TmpBuf2);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			ezplib_replace_attr("snmpd_upgrade_rule",0,"protocol",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeProtocol\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set upgrade firmware start
+* only '1' is valid
+* get operation is nonsense
+* read-write
+*/
+int
+handle_fwUpgradeAction(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char cmd[Tmp_Len*4],proto[Tmp_Len],ipaddr[Tmp_Len],filename[Tmp_Len];
+	char username[Tmp_Len],password[Tmp_Len];
+	char tmp_filenm[Tmp_Len],Tmp_buf[Tmp_Len];
+	FILE* fd=NULL;
+	int file_length=0,pid;
+	int file_begin, file_end;
+	int file_new_begin = -1;
+	int file_middle = 0;
+	int rootfs_begin = 0;
+    int upgradestatus;
+	image_header_t *hdr2=NULL;
+    
+	unsigned long fw_kernel_len = 0;
+	char err_msg[Tmp_Len*2];
+	memset(proto,0,sizeof(proto));
+	memset(ipaddr,0,sizeof(ipaddr));
+	memset(filename,0,sizeof(filename));
+
+	memset(cmd,0,sizeof(cmd));
+	memset(tmp_filenm,0,sizeof(tmp_filenm));
+	memset(Tmp_buf,0,sizeof(Tmp_buf));
+	memset(err_msg,0,sizeof(err_msg));
+	memset(username,0,sizeof(username));
+	memset(password,0,sizeof(password));
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=0;
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			/* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			if(ret != 1)
+			{
+                set_upgrade_status(UPGRADE_UNSUPPORTED); //unsupported
+
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			ezplib_get_attr_val("snmpd_upgrade_rule", 0, "protocol", proto, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("snmpd_upgrade_rule", 0, "ipaddr", ipaddr, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("snmpd_upgrade_rule", 0, "filename", filename, Tmp_Len, EZPLIB_USE_CLI);
+			//ezplib_get_attr_val("snmpd_upgrade_rule", 0, "status", status, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("snmpd_upgrade_rule", 0, "username", username, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("snmpd_upgrade_rule", 0, "password", password, Tmp_Len, EZPLIB_USE_CLI);
+
+            upgradestatus = get_upgrade_status();
+
+	        if(upgradestatus == UPGRADE_BUSY || upgradestatus == UPGRADE_DOWNLOADING
+                || upgradestatus == UPGRADE_WRITING) //system busy
+            {
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
+				break;
+            }
+
+			if(strlen(ipaddr) <= 0 || strlen(filename) <= 0)
+			{
+                set_upgrade_status(UPGRADE_DOWNLOAD_FAIL); //download fail
+
+				system("rm /tmp/fw_uploading -f");
+				send_cpefileUpfwStatus_trap();
+				break;
+			}
+			printf("start firmware update,please don't poweroff\n");
+
+            set_upgrade_status(UPGRADE_BUSY); //busy
+
+			system("echo busy > /tmp/fw_uploading");
+            
+			pid = fork();
+			if(pid == -1)
+			{
+                set_upgrade_status(UPGRADE_NO_SPACE); //no space
+
+				system("rm /tmp/fw_uploading -f");
+				send_cpefileUpfwStatus_trap();
+				break;
+			}
+			else if(pid == 0)//child process
+			{
+			    set_upgrade_status(UPGRADE_DOWNLOADING); //downloading
+
+				if(0 == atoi(proto))
+					sprintf(cmd,"cd /tmp && tftp-hpa -m binary %s -c get %s",ipaddr,filename);
+				else
+				{
+					//sprintf(cmd,"ftpget %s /tmp/%s %s",ipaddr,filename,filename);
+					sprintf(cmd,"cd /tmp && curl -u '%s:%s' ftp://%s/%s --max-filesize 0x800000 > /tmp/%s",username,password,ipaddr,filename,filename);
+				}
+				printf("%s\n",cmd);
+				system(cmd);
+				sprintf(tmp_filenm,"/tmp/%s.txt",filename);
+				sprintf(cmd,"ls /tmp/ -l | grep %s | awk '{print $5}' > %s",filename,tmp_filenm);
+				printf("%s\n",cmd);
+				system(cmd);
+				system("sync");
+				fd=fopen(tmp_filenm,"r");
+				fscanf(fd,"%s",Tmp_buf);
+				fclose(fd);
+				sprintf(cmd,"rm -f %s",tmp_filenm);
+				system(cmd);
+				if(strlen(Tmp_buf) == 0 || atoi(Tmp_buf) == 0)
+				{
+					printf("download file failed,please check Ipaddress and server!\n");
+					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOSUCHNAME);
+
+                    set_upgrade_status(UPGRADE_DOWNLOAD_FAIL);
+
+					send_cpefileUpfwStatus_trap();
+					exit(0);
+				}
+				file_length = atoi(Tmp_buf);
+				printf("download file success,lenght is %d!\n",file_length);
+				
+				//chech firmware is valid?
+				file_begin = 0;
+				file_end = file_length;
+				sprintf(tmp_filenm,"/tmp/%s",filename);
+				if(!check(tmp_filenm, file_begin, file_end - file_begin, err_msg, &fw_kernel_len))
+				{
+					printf("firmware is not valid: %s\n", err_msg);
+					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
+
+                    set_upgrade_status(UPGRADE_FW_INVALID); //invalid
+	
+					send_cpefileUpfwStatus_trap();
+
+					exit(0);
+				}
+
+            	ezp_special_process();    
+                printf("fw_kernel_len=0x%x, start write flash ... \n", fw_kernel_len);
+                
+            	sleep(3);
+
+                file_new_begin = file_begin + sizeof(prefix_image_header_t);
+
+            	file_middle = file_new_begin + sizeof(image_header_t) + fw_kernel_len;
+
+                set_upgrade_status(UPGRADE_WRITING); //writing
+                
+                //start upgrade
+                //mtd_write_firmware(filename, file_new_begin, file_end - file_begin); origin  function
+                snprintf(cmd, 512, "cd /tmp && /usr/sbin/mtd_write -o %d -l %d write %s kernel", file_new_begin, file_middle-file_new_begin, filename);
+                printf("%s\n",cmd);
+                system(cmd);
+            	memset(cmd,0,512);
+            	snprintf(cmd, 512, "cd /tmp && /usr/sbin/mtd_write -o %d -l %d write %s rootfs", file_middle, file_end-file_middle, filename);
+                printf("%s\n",cmd);
+                system(cmd);
+            	memset(cmd,0,512);
+            	snprintf(cmd, 512, "logger EZP_USR  %s\n","FW Upgrade Successful!" );
+            	system(cmd);
+                
+                system("sync");
+
+                set_upgrade_status(UPGRADE_SUCCESSD);  //success
+
+				system("rm /tmp/fw_uploading -f");
+				
+				send_cpefileUpfwStatus_trap();
+                
+				sleep(5);
+                
+				reboot(RB_AUTOBOOT);
+			}
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            //not need undo,otherwise,we cannot trace the fileoperation status
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeAction\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*get firmware upgrade status
+* 0   busy: The operation is in progress
+* 1   success: the operation completed without error
+* 2   unsupported: the device does not support the specified fwUpgradeAction
+* 3   download fail: The operation required a valid fwUpgradeAddress or filename was not specified
+* 4   firmware invalid: the file operation was initiated, but failed during file transfer
+* 5   no space: the device did not have enough space to complete the operation
+* read-only
+*/
+int
+handle_fwUpgradeStatus(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    int ret;
+
+#ifdef UPGRADE_STATUS_IN_NVMRAM  
+	char TmpBuf[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "status", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+#else
+
+#endif
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+#ifdef UPGRADE_STATUS_IN_NVMRAM  
+			if(strlen(TmpBuf)>0)
+			{
+
+				ret = atoi(TmpBuf);
+  	            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+			}
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,NULL,0);
+#else
+            ret = get_upgrade_status();
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+#endif
+
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeStatus\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get server username
+* 1. lenth must gt 4 and lt 128
+* 2. suffix is ".bin"
+* read-write
+*/
+int
+handle_fwUpgradeUser(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char username[Tmp_Len],TmpBuf[Tmp_Len];
+	int tmplen=0,j=0;
+    memset(username,0,sizeof(username));
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "username", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			if(strlen(TmpBuf) > 0)
+            	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,TmpBuf,strlen(TmpBuf));
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,NULL,0);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+            /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			if(requests->requestvb->val_len >= Tmp_Len/4)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			tmplen = requests->requestvb->val_len;
+			if(tmplen > 0)
+			{
+				strncpy(username,requests->requestvb->val.string,tmplen);
+				username[tmplen] = '\0';
+				printf("%s: user name %s\n",__func__, username);
+				tmplen=0;
+				for(j=0;j<strlen(username);j++)
+				{
+					if((int)username[j] < 0)
+					{
+						tmplen=1;
+						break;
+					}
+					if(username[j] == '^' || username[j] == '`' || username[j] == '"'
+					|| username[j] == '\'' || username[j] == '|' || username[j] == '%' || username[j] == '?' || username[j] == '<' || username[j] == '>')
+					{
+						tmplen=1;
+						break;
+					}
+				}
+				if(tmplen == 1)
+				{
+					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				}
+			}
+			
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			/* XXX: perform the value change here */
+			tmplen = requests->requestvb->val_len;
+			if(tmplen > 0)
+			{
+				strncpy(username,requests->requestvb->val.string,tmplen);
+				username[tmplen] = '\0';
+				printf("%s: username %s\n",__func__, username);
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"username",username);
+			}
+			else
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"username","");
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if(strlen(TmpBuf) > 0)
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"username",TmpBuf);
+			else
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"username","");
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeUser\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get server password
+* 1. lenth must gt 4 and lt 128
+* 2. suffix is ".bin"
+* read-write
+*/
+int
+handle_fwUpgradePwd(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char password[Tmp_Len],TmpBuf[Tmp_Len];
+	int tmplen=0,j=0;
+    memset(password,0,sizeof(password));
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "password", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			if(strlen(TmpBuf) > 0)
+            	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,TmpBuf,strlen(TmpBuf));
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,NULL,0);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+            /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			if(requests->requestvb->val_len >= Tmp_Len/4)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			tmplen = requests->requestvb->val_len;
+			if(tmplen > 0)
+			{
+				strncpy(password,requests->requestvb->val.string,tmplen);
+				password[tmplen] = '\0';
+				printf("%s: password %s\n",__func__, password);
+				tmplen=0;
+				for(j=0;j<strlen(password);j++)
+				{
+					if((int)password[j] < 0)
+					{
+						tmplen=1;
+						break;
+					}
+					if(password[j] == '^' || password[j] == '`' || password[j] == '"'
+					|| password[j] == '\'' || password[j] == '|' || password[j] == '%' || password[j] == '?' || password[j] == '<' || password[j] == '>')
+					{
+						tmplen=1;
+						break;
+					}
+				}
+				if(tmplen == 1)
+				{
+					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				}
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			/* XXX: perform the value change here */
+			tmplen = requests->requestvb->val_len;
+			if(tmplen > 0)
+			{
+				strncpy(password,requests->requestvb->val.string,tmplen);
+				password[tmplen] = '\0';
+				printf("%s: password %s\n",__func__, password);
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"password",password);
+			}
+			else
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"password","");
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            if(strlen(TmpBuf) > 0)
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"password",TmpBuf);
+			else
+				ezplib_replace_attr("snmpd_upgrade_rule",0,"password","");
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradePwd\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*send upgrade status to server through v2trap
+* 1   success: the operation completed without error
+* 3   download fail: The operation required a valid fwUpgradeAddress or filname was not specified
+* 4   firmware invalid: the file operation was initiated, but failed during file transfer
+* 5   no space: the device did not have enough space to complete the operation
+*/
+int
+send_cpefileUpfwStatus_trap( void )
+{
+    netsnmp_variable_list  *var_list = NULL;
+
+	int ret;
+	char TmpBuf[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("snmpd_upgrade_rule", 0, "status", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    /*
+     * Set the snmpTrapOid.0 value
+     */
+    snmp_varlist_add_variable(&var_list,
+        snmptrap_oid, OID_LENGTH(snmptrap_oid),
+        ASN_OBJECT_ID,
+        cpefileUpfwStatus_oid, sizeof(cpefileUpfwStatus_oid));
+
+
+    /*
+     * Add any extra (optional) objects here
+     */
+     if(strlen(TmpBuf) > 0)
+     {
+     	ret = atoi(TmpBuf);
+     	snmp_varlist_add_variable(&var_list,
+            cpefileUpfwStatus_oid, OID_LENGTH(cpefileUpfwStatus_oid),
+            ASN_INTEGER,
+            (u_char *)&ret,
+            sizeof(ret));
+     }
+
+    /*
+     * Send the trap to the list of configured destinations
+     *  and clean up
+     */
+    send_v2trap( var_list );
+    snmp_free_varbind( var_list );
+
+    return SNMP_ERR_NOERROR;
+}
+
+static unsigned int getMTDPartSize(char *part)
+{
+	char buf[128], name[32], size[32], dev[32], erase[32];
+	unsigned int result=0;
+	FILE *fp = fopen("/proc/mtd", "r");
+	if(!fp){
+		fprintf(stderr, "mtd support not enable?");
+		return 0;
+	}
+	while(fgets(buf, 512, fp)){
+		sscanf(buf, "%s %s %s %s", dev, size, erase, name);
+		if(!strcmp(name, part)){
+			result = strtol(size, NULL, 16);
+			break;
+		}
+	}
+	fclose(fp);
+	return result;
+}
+
+
+/*
+ *  check whether firmware is valid or not
+ *
+ *  imagefile: file path
+ *  offset: offset in file
+ *  len: file total length
+ *  err_msg: msg for output
+ *  kernel_len: kernel length for output
+ */
+int check(char *imagefile, int offset, int len, char *err_msg, unsigned long *kernel_len)
+{
+	struct stat sbuf;
+
+	int  header_len1 = 0 ;
+	int  header_len2 = 0 ;
+	unsigned char *ptr1 = NULL;
+	unsigned char *ptr2 = NULL;
+	unsigned long checksum1 = 0;
+	unsigned long checksum2 = 0;
+	prefix_image_header_t header1;
+	image_header_t header2;
+	prefix_image_header_t *hdr1 = &header1;
+	image_header_t *hdr2 = &header2;
+	int ifd = 0;
+	int len1 = len;
+	int len2 = len - sizeof(prefix_image_header_t);
+
+	if ((unsigned)(len1) < sizeof(prefix_image_header_t)||
+		(unsigned)(len2) < sizeof(image_header_t)) 
+	{
+		sprintf (err_msg, "Bad size: \"%s\" is no valid image\n", imagefile);
+		return 0;
+	}
+
+	ifd = open(imagefile, O_RDONLY);
+	if(!ifd)
+	{
+		sprintf (err_msg, "Can't open %s: %s\n", imagefile, strerror(errno));
+		return 0;
+	}
+
+	if (fstat(ifd, &sbuf) < 0) 
+	{
+		close(ifd);
+		sprintf (err_msg, "Can't stat %s: %s\n", imagefile, strerror(errno));
+		return 0;
+	}
+
+	ptr1 = (unsigned char *) mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, ifd, 0);
+	ptr2 = (unsigned char *) mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, ifd, 0);
+	if ((caddr_t)ptr1 == (caddr_t)-1) 
+	{
+		close(ifd);
+		sprintf (err_msg, "Can't mmap %s: %s\n", imagefile, strerror(errno));
+		return 0;
+	}
+
+	ptr1 += offset;
+	ptr2 += sizeof(prefix_image_header_t);
+
+	/*
+	 *	handle Header CRC32
+	 */
+	memcpy (hdr1, ptr1, sizeof(prefix_image_header_t));
+	memcpy (hdr2, ptr2, sizeof(image_header_t));
+
+    //check PIH_MAGIC (defined in the top .config)
+//#ifdef PIH_MAGIC	
+	if (ntohl(hdr1->pih_magic) != PIH_MAGIC) 
+	{
+		sprintf (err_msg, "Bad Magic Number: \"%s\" is not valid image\n", imagefile);
+		goto err;
+	}
+//#else
+//	fprintf(stderr,"PIH_MAGIC is not defined as a marco\r\n");	
+//#endif
+
+	header_len1 = sizeof(prefix_image_header_t);
+	checksum1 = ntohl(hdr1->pih_hcrc);
+	hdr1->pih_hcrc = htonl(0);	/* clear for re-calculation */
+
+	if (crc32 (0, (char *)hdr1, header_len1) != checksum1) 
+	{
+		sprintf (err_msg, "Bad Header1 CRC: %8.8x: \"%s\" is not valid image\n", checksum1, imagefile);
+		goto err;
+	}
+
+	header_len2 = sizeof(image_header_t);
+	checksum2 = ntohl(hdr2->ih_hcrc);
+	hdr2->ih_hcrc = htonl(0);	/* clear for re-calculation */
+
+	if (crc32 (0, (char *)hdr2, header_len2) != checksum2) 
+	{
+		sprintf (err_msg, "Bad Header2 CRC: %8.8x: \"%s\" is not valid image\n", checksum2, imagefile);
+		goto err;
+	}
+
+    /* check image name: must have special string in image name*/
+    if(!strstr(hdr2->ih_name, IMAGE_NAME_IN_HEADER) && !strstr(hdr2->ih_name, IMAGE_NAME2_IN_HEADER)
+        && !strstr(hdr2->ih_name, IMAGE_NAME3_IN_HEADER))
+    {
+		printf("Firmware is not valid for this product\n");					
+		goto err;
+    }
+
+	/*
+	 *	handle Data CRC32
+	 */
+	char *data = (char *)(ptr1 + sizeof(prefix_image_header_t));
+	unsigned long data_len  = len1 - sizeof(prefix_image_header_t) ;
+	
+	if (crc32 (0, data, data_len) != ntohl(hdr1->pih_dcrc)) 
+	{
+		printf("Firmware has bad data checksum!\n");						
+		goto err;
+	}
+
+    /* return kernel image size*/
+    *kernel_len = hdr2->ih_size;
+
+	munmap(ptr1, len1);
+    munmap(ptr2, len2);
+	close(ifd);
+
+	return 1;
+
+err:
+    munmap(ptr1, len1);
+    munmap(ptr2, len2);
+	close(ifd);
+    
+	return 0;
+}
+
+/* Copy file from fsrc to fdest */
+static int
+ezp_copy_file(char *fsrc, char *fdest) 
+{
+    FILE *srcfp = NULL, *destfp = NULL;
+    unsigned char *buf = NULL;
+    int len, retval = 0;
+
+
+    if (!fsrc || !fdest || !*fsrc || !*fdest) {
+        retval = 1;
+        goto src_err;
+    }
+    srcfp = fopen(fsrc, "r");
+    if (!srcfp) {
+        retval = 1;
+        goto src_err;
+    }
+    destfp = fopen(fdest, "w");
+    if (!destfp) {
+        retval = 1;
+        goto dest_err;
+    }
+    buf = (unsigned char*)malloc(8192);
+    if (!buf) {
+        retval = 1;
+        goto alloc_err;
+    }
+    while ((len = fread(buf, 1, 8192, srcfp)) > 0) {
+        fwrite(buf, 1, len, destfp);
+    }
+    free(buf);
+alloc_err:
+    fclose(destfp);
+dest_err:
+    fclose(srcfp);
+src_err:
+    return retval;
+}
+
+/*copy some special files*/
+void ezp_special_process()
+{
+	printf("\nezp_special_process()\n");
+	
+	/* Disable network service */
+    system("echo \"0\" > /proc/sys/net/ipv4/ip_forward");
+    /* For reboot normal. Because firmware upgraade will produce squashfs
+     * error when system execute reboot from flash. */
+    /* The following files are required after firmware and file system 
+     * upgraded.
+     *
+     * It includes
+     *   1. busybox and related symbolic links
+     *   2. uclibc libraries
+     *   3. nvram libraries
+     *   4. upgrade finishing page
+     * */
+    if (ezp_copy_file("/bin/busybox", "/tmp/busybox")) {
+        printf("copy /bin/busybox to /tmp/busybox failed\n");
+    }
+    if (ezp_copy_file("/tmp/busybox", "/bin/busybox")) {
+        printf("copy /tmp/busybox to /bin/busybox failed\n");
+    }
+    system("chmod 777 /tmp/busybox");
+#if 0
+    if (ezp_copy_file("/lib/libuClibc-0.9.28.so","/tmp/libuClibc-0.9.28.so")) {
+        printf("copy /lib/libuClibc-0.9.28.so /tmp/libuClibc-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libuClibc-0.9.28.so","/lib/libuClibc-0.9.28.so")) {
+        printf("copy /tmp/libuClibc-0.9.28.so /lib/libuClibc-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/lib/ld-uClibc-0.9.28.so","/tmp/ld-uClibc-0.9.28.so")) {
+        printf("copy /lib/ld-uClibc-0.9.28.so /tmp/ld-uClibc-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/ld-uClibc-0.9.28.so","/lib/ld-uClibc-0.9.28.so")) {
+        printf("copy /tmp/ld-uClibc-0.9.28.so /lib/ld-uClibc-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libdl-0.9.28.so","/tmp/libdl-0.9.28.so")) {
+        printf("copy /lib/libdl-0.9.28.so /tmp/libdl-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libdl-0.9.28.so","/lib/libdl-0.9.28.so")) {
+        printf("copy /tmp/libdl-0.9.28.so /lib/libdl-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libm-0.9.28.so","/tmp/libm-0.9.28.so")) {
+        printf("copy /lib/libm-0.9.28.so /tmp/libm-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libm-0.9.28.so","/lib/libm-0.9.28.so")) {
+        printf("copy /tmp/libm-0.9.28.so /lib/libm-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libnsl-0.9.28.so","/tmp/libnsl-0.9.28.so")) {
+        printf("copy /lib/libnsl-0.9.28.so /tmp/libnsl-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libnsl-0.9.28.so","/lib/libnsl-0.9.28.so")) {
+        printf("copy /tmp/libnsl-0.9.28.so /lib/libnsl-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libutil-0.9.28.so","/tmp/libutil-0.9.28.so")) {
+        printf("copy /lib/libutil-0.9.28.so /tmp/libutil-0.9.28.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libutil-0.9.28.so","/lib/libutil-0.9.28.so")) {
+        printf("copy /tmp/libutil-0.9.28.so /lib/libutil-0.9.28.so failed\n");
+    }
+#else
+    if (ezp_copy_file("/lib/libuClibc-0.9.30.so","/tmp/libuClibc-0.9.30.so")) {
+        printf("copy /lib/libuClibc-0.9.30.so /tmp/libuClibc-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libuClibc-0.9.30.so","/lib/libuClibc-0.9.30.so")) {
+        printf("copy /tmp/libuClibc-0.9.30.so /lib/libuClibc-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/lib/ld-uClibc-0.9.30.so","/tmp/ld-uClibc-0.9.30.so")) {
+        printf("copy /lib/ld-uClibc-0.9.30.so /tmp/ld-uClibc-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/ld-uClibc-0.9.30.so","/lib/ld-uClibc-0.9.30.so")) {
+        printf("copy /tmp/ld-uClibc-0.9.30.so /lib/ld-uClibc-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libdl-0.9.30.so","/tmp/libdl-0.9.30.so")) {
+        printf("copy /lib/libdl-0.9.30.so /tmp/libdl-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libdl-0.9.30.so","/lib/libdl-0.9.30.so")) {
+        printf("copy /tmp/libdl-0.9.30.so /lib/libdl-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libm-0.9.30.so","/tmp/libm-0.9.30.so")) {
+        printf("copy /lib/libm-0.9.30.so /tmp/libm-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libm-0.9.30.so","/lib/libm-0.9.30.so")) {
+        printf("copy /tmp/libm-0.9.30.so /lib/libm-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libnsl-0.9.30.so","/tmp/libnsl-0.9.30.so")) {
+        printf("copy /lib/libnsl-0.9.30.so /tmp/libnsl-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libnsl-0.9.30.so","/lib/libnsl-0.9.30.so")) {
+        printf("copy /tmp/libnsl-0.9.30.so /lib/libnsl-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/lib/libutil-0.9.30.so","/tmp/libutil-0.9.30.so")) {
+        printf("copy /lib/libutil-0.9.30.so /tmp/libutil-0.9.30.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libutil-0.9.30.so","/lib/libutil-0.9.30.so")) {
+        printf("copy /tmp/libutil-0.9.30.so /lib/libutil-0.9.30.so failed\n");
+    }
+#endif
+    if (ezp_copy_file("/usr/lib/libnvram.so","/tmp/libnvram.so")) {
+        printf("copy /usr/lib/libnvram.so /tmp/libnvram.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libnvram.so","/usr/lib/libnvram.so")) {
+        printf("copy /tmp/libnvram.so /usr/lib/libnvram.so failed\n");
+    }
+    if (ezp_copy_file("/usr/lib/libshared.so","/tmp/libshared.so")) {
+        printf("copy /usr/lib/libshared.so /tmp/libshared.so failed\n");
+    }
+    if (ezp_copy_file("/tmp/libshared.so","/usr/lib/libshared.so")) {
+        printf("copy /tmp/libshared.so /usr/lib/libshared.so failed\n");
+    }
+
+    unlink("/sbin/reboot");
+    unlink("/bin/sync");
+
+    printf("ezp_special_process() end\n");
+    
+    //symlink("/bin/busybox","/tmp/reboot");
+    //symlink("/bin/busybox","/sbin/reboot");
+}
+
+
+/*
+ * check fw_uploading status file is exist or not. 
+ * this file is controlled by SNMP action. 
+ * return 0: file don't exist. It's ok to upgrad.
+ *          1: file exist. 
+ */
+int get_fw_uploading()
+{
+    int status;
+    struct stat stat_buf;
+    
+    if(stat(FW_UPLOADING_STATUS_FILE, &stat_buf) < 0)
+    {
+        /* file don't exist*/
+        return 0;
+    }else
+    {
+        /* file exist*/
+        return 1;
+    }
+}
+
+/*
+ * set_upgrade_status, status defined in upgrade_status_t.
+ * keep the implementation same as in uploadcgi.c
+ */
+void set_upgrade_status(int new_status)
+{
+    char cmd[64];
+    
+    if(new_status >= UPGRADE_STATUS_MAX  || new_status < 0)
+    {
+        printf("set_upgrade_status: status %d out of range\n", new_status);
+
+        return;
+    }
+
+    /*
+    UPGRADE_BUSY,
+    UPGRADE_SUCCESSD,
+    UPGRADE_UNSUPPORTED,
+    UPGRADE_DOWNLOAD_FAIL,
+    UPGRADE_FW_INVALID,
+    UPGRADE_NO_SPACE,
+    UPGRADE_DOWNLOADING,
+    UPGRADE_WRITING,
+    UPGRADE_STATUS_MAX,
+    */
+    switch(new_status)
+    {
+        case UPGRADE_BUSY:
+            sprintf(cmd, "echo %s", "busy"); 
+            break;
+        case UPGRADE_SUCCESSD:
+            sprintf(cmd, "echo %s", "ok"); 
+            break;
+        case UPGRADE_UNSUPPORTED:
+            sprintf(cmd, "echo %s", "unsupported"); 
+            break;
+        case UPGRADE_DOWNLOAD_FAIL:
+            sprintf(cmd, "echo %s", "dl_fail"); 
+            break;
+        case UPGRADE_FW_INVALID:
+            sprintf(cmd, "echo %s", "fw_invalid"); 
+            break;
+        case UPGRADE_NO_SPACE:
+            sprintf(cmd, "echo %s", "no_space"); 
+            break;
+        case UPGRADE_DOWNLOADING:
+            sprintf(cmd, "echo %s", "downloading"); 
+            break;
+        case UPGRADE_WRITING:
+            sprintf(cmd, "echo %s", "writing"); 
+            break;
+        default:
+            sprintf(cmd, "echo %s", "unknown");
+            break;
+    }
+
+    sprintf(cmd, "%s > %s",cmd, FW_UPLOADING_STATUS_FILE);
+    
+    printf("%s\n", cmd);
+
+    system(cmd);
+
+    return;
+}
+
+/*
+ * set_upgrade_status 
+ */
+int get_upgrade_status()
+{
+    FILE *fp;
+    char buf[64];
+
+    if(get_fw_uploading() == 0)
+    {
+        return UPGRADE_SUCCESSD; 
+    }
+    
+    fp = fopen(FW_UPLOADING_STATUS_FILE, "r");
+    if(fp == NULL)
+    {
+        printf("get_upgrade_status: open/create file fail\n");
+
+        return UPGRADE_UNSUPPORTED; 
+    }
+
+    /*
+    UPGRADE_BUSY,
+    UPGRADE_SUCCESSD,
+    UPGRADE_UNSUPPORTED,
+    UPGRADE_DOWNLOAD_FAIL,
+    UPGRADE_FW_INVALID,
+    UPGRADE_NO_SPACE,
+    UPGRADE_DOWNLOADING,
+    UPGRADE_WRITING,
+    UPGRADE_STATUS_MAX,
+    */
+	if(fgets(buf, 60, fp))
+    {
+        if(strcmp(buf, "busy\n") == 0)
+        {
+            return UPGRADE_BUSY;
+        }else if(strcmp(buf, "ok\n") == 0)
+        {
+            return UPGRADE_SUCCESSD;
+        }else if(strcmp(buf, "unsupported\n") == 0)
+        {
+            return UPGRADE_UNSUPPORTED;
+        }else if(strcmp(buf, "dl_fail\n") == 0)
+        {
+            return UPGRADE_DOWNLOAD_FAIL;
+        }else if(strcmp(buf, "fw_invalid\n") == 0)
+        {
+            return UPGRADE_FW_INVALID;
+        }else if(strcmp(buf, "no_space\n") == 0)
+        {
+            return UPGRADE_NO_SPACE;
+        }else if(strcmp(buf, "downloading\n") == 0)
+        {
+            return UPGRADE_DOWNLOADING;
+        }else if(strcmp(buf, "writing\n") == 0)
+        {
+            return UPGRADE_WRITING;
+        }else
+        {
+            printf("get_upgrade_status: unknown status: %s\n", buf);
+            return UPGRADE_UNSUPPORTED;
+        }
+
+	}else{
+
+        printf("get_upgrade_status: fgets error\n");
+
+        fclose(fp);
+
+        return UPGRADE_UNSUPPORTED;
+    }
+	
+    return UPGRADE_UNSUPPORTED;
+}
+
diff -Nrup net-snmp-5.7.2-old/agent/mibgroup/CPEUpFirmwareModule.h net-snmp-5.7.2-new/agent/mibgroup/CPEUpFirmwareModule.h
--- net-snmp-5.7.2-old/agent/mibgroup/CPEUpFirmwareModule.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.7.2-new/agent/mibgroup/CPEUpFirmwareModule.h	2014-07-10 08:44:35.828992045 -0700
@@ -0,0 +1,95 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 17798 2009-10-27 06:44:54Z magfr $
+ * Author:Alvin ke
+ * revision: initial
+ * maily for upgrade firmware through snmp
+ * date: 2013-5-9
+ */
+#ifndef CPEUPFIRMWAREMODULE_H
+#define CPEUPFIRMWAREMODULE_H
+
+#include "nvram_rule.h"
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/reboot.h>
+
+#define Tmp_Len 128
+#define MEM_SIZE	1024
+#define MEM_HALF	512
+//#define IH_MAGIC	0x27051956
+//#define IH_MAGIC    0x4C383338
+
+#define IMAGE_NAME_IN_HEADER "WCHS01"
+#define IMAGE_NAME2_IN_HEADER "wchs01"
+#define IMAGE_NAME3_IN_HEADER "WCHS"
+
+
+#define FW_UPLOADING_STATUS_FILE "/tmp/fw_uploading"
+
+//#define UPGRADE_STATUS_IN_NVMRAM 1
+
+#define IH_NMLEN	32
+typedef struct image_header {
+    uint32_t    ih_magic;   /* Image Header Magic Number    */
+    uint32_t    ih_hcrc;    /* Image Header CRC Checksum    */
+    uint32_t    ih_time;    /* Image Creation Timestamp */
+    uint32_t    ih_size;    /* Image Data Size      */
+    uint32_t    ih_load;    /* Data  Load  Address      */
+    uint32_t    ih_ep;      /* Entry Point Address      */
+    uint32_t    ih_dcrc;    /* Image Data CRC Checksum  */
+    uint8_t     ih_os;      /* Operating System     */
+    uint8_t     ih_arch;    /* CPU architecture     */
+    uint8_t     ih_type;    /* Image Type           */
+    uint8_t     ih_comp;    /* Compression Type     */
+    uint8_t     ih_name[IH_NMLEN];  /* Image Name       */
+} image_header_t;
+
+
+typedef struct prefix_image_header{
+	uint32_t    pih_magic;   /* Image Header Magic Number    */
+	uint32_t    pih_hcrc;    /* Image Header CRC Checksum    */
+	uint32_t    pih_size;    /* Image Data Size      */
+	uint32_t    pih_dcrc;    /* Image Data CRC Checksum  */		
+}prefix_image_header_t;
+
+enum upgrade_status{
+    UPGRADE_BUSY,
+    UPGRADE_SUCCESSD,
+    UPGRADE_UNSUPPORTED,
+    UPGRADE_DOWNLOAD_FAIL,
+    UPGRADE_FW_INVALID,
+    UPGRADE_NO_SPACE,
+    UPGRADE_DOWNLOADING,
+    UPGRADE_WRITING,
+    UPGRADE_STATUS_MAX,
+}upgrade_status_t;
+
+/* function declarations */
+void init_CPEUpFirmwareModule(void);
+int send_cpefileUpfwStatus_trap(void);
+int firmwareisvalid(const char *file);
+int check(char *imagefile, int offset, int len, char *err_msg, unsigned long *kernel_len);
+void ezp_special_process();
+int get_fw_uploading();
+void set_upgrade_status(upgrade_status_t );
+int get_upgrade_status();
+
+Netsnmp_Node_Handler handle_cpesystemstatus;
+Netsnmp_Node_Handler handle_fwUpgradeFilename;
+Netsnmp_Node_Handler handle_fwUpgradeAddress;
+Netsnmp_Node_Handler handle_fwUpgradeProtocol;
+Netsnmp_Node_Handler handle_fwUpgradeAction;
+Netsnmp_Node_Handler handle_fwUpgradeStatus;
+Netsnmp_Node_Handler handle_fwUpgradeUser;
+Netsnmp_Node_Handler handle_fwUpgradePwd;
+
+#endif /* CPEUPFIRMWAREMODULE_H */
+
+
+
diff -Nrup net-snmp-5.7.2-old/agent/snmpd.c net-snmp-5.7.2-new/agent/snmpd.c
--- net-snmp-5.7.2-old/agent/snmpd.c	2014-07-08 05:25:26.094536989 -0700
+++ net-snmp-5.7.2-new/agent/snmpd.c	2014-07-08 09:21:45.131118559 -0700
@@ -1189,6 +1189,7 @@ receive(void)
 #ifdef	USING_SMUX_MODULE
     int             sd;
 #endif                          /* USING_SMUX_MODULE */
+	int pidstatus;
 
     netsnmp_large_fd_set_init(&readfds, FD_SETSIZE);
     netsnmp_large_fd_set_init(&writefds, FD_SETSIZE);
@@ -1207,6 +1208,7 @@ receive(void)
      * Loop-forever: execute message handlers for sockets with data
      */
     while (netsnmp_running) {
+		waitpid(-1,&pidstatus,WNOHANG);//Alvin add to recycle zombie process
         if (reconfig) {
 #if HAVE_SIGHOLD
             sighold(SIGHUP);
