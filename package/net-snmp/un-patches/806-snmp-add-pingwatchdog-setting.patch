diff -Nur net-snmp-5.4.2.1/agent/mibgroup_old/CPEPingWatchdogModule.c net-snmp-5.4.2.1/agent/mibgroup/CPEPingWatchdogModule.c
--- net-snmp-5.4.2.1/agent/mibgroup_old/CPEPingWatchdogModule.c	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.4.2.1/agent/mibgroup/CPEPingWatchdogModule.c	2013-07-25 18:30:55.173552603 +0800
@@ -0,0 +1,593 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 17798 2009-10-27 06:44:54Z magfr $
+ * Author:Alvin ke
+ * revision: initial
+ * maily for setting parameters of ping watchdog through snmp
+ * date: 2013-7-25
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "CPEPingWatchdogModule.h"
+
+static const oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};
+extern int errno;
+
+
+/** Initializes the CPEUpFirmwareModule module */
+void
+init_CPEPingWatchdogModule(void)
+{
+    const oid pingwatchdogRunStat_oid[] = { 1,3,6,1,4,1,50000,1,688,2,1 };
+    const oid pingwatchdogPingAddress_oid[] = { 1,3,6,1,4,1,50000,1,688,2,2 };
+	const oid pingwatchdogPingInterval_oid[] = { 1,3,6,1,4,1,50000,1,688,2,3 };
+    const oid pingwatchdogDelay_oid[] = { 1,3,6,1,4,1,50000,1,688,2,4 };
+    const oid pingwatchdogfailcount_oid[] = { 1,3,6,1,4,1,50000,1,688,2,5 };
+
+  DEBUGMSGTL(("CPEPingWatchdogModule", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("pingwatchdogRunStat", handle_pingwatchdogRunStat,
+                               pingwatchdogRunStat_oid, OID_LENGTH(pingwatchdogRunStat_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("pingwatchdogPingAddress", handle_pingwatchdogPingAddress,
+                               pingwatchdogPingAddress_oid, OID_LENGTH(pingwatchdogPingAddress_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+	netsnmp_register_scalar(
+        netsnmp_create_handler_registration("pingwatchdogPingInterval", handle_pingwatchdogPingInterval,
+                               pingwatchdogPingInterval_oid, OID_LENGTH(pingwatchdogPingInterval_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("pingwatchdogDelay", handle_pingwatchdogDelay,
+                               pingwatchdogDelay_oid, OID_LENGTH(pingwatchdogDelay_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("pingwatchdogfailcount", handle_pingwatchdogfailcount,
+                               pingwatchdogfailcount_oid, OID_LENGTH(pingwatchdogfailcount_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+}
+
+/*set/get ping IP Address
+* don't allow 255.255.255.255 or 0.0.0.0
+* read-write
+*/
+int
+handle_pingwatchdogPingAddress(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+
+	char *ipaddr,TmpBuf[Tmp_Len];
+	u_long result;
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("pwatchdog_rule", 0, "ip", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			if(strlen(TmpBuf) > 0)
+			{
+				result=inet_addr(TmpBuf);
+            	snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&result,sizeof(result));
+			}
+			else
+				snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,NULL,0);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			result = *(requests->requestvb->val.integer);
+			ipaddr = inet_ntoa(result);
+			if (ipaddr == NULL)
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+				break;
+			}
+			printf("%s: result %08x, IP adrress %s\n",__func__, result,ipaddr);
+			if((strcmp(ipaddr, "255.255.255.255") == 0) || (strcmp(ipaddr, "0.0.0.0") == 0))
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			result = *(requests->requestvb->val.integer);
+			ipaddr = inet_ntoa(result);
+			printf("%s: result %08x, IP adrress %s\n",__func__, result,ipaddr);
+			ezplib_replace_attr("pwatchdog_rule",0,"ip",ipaddr);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			if(strlen(TmpBuf) > 0)
+				ezplib_replace_attr("pwatchdog_rule",0,"ip",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeAddress\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get transfer protocol
+* it's only support tftp(0),ftp(1)
+* read-write
+*/
+int
+handle_pingwatchdogPingInterval(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char TmpBuf[Tmp_Len];
+	char TmpBuf2[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	memset(TmpBuf2,0,sizeof(TmpBuf2));
+	ezplib_get_attr_val("pwatchdog_rule", 0, "interval", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(TmpBuf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			ret = *(requests->requestvb->val.integer);
+			printf("interval is %d\n",ret);
+			if(ret > 3600 || ret < 10)//range 10~3600 seconds
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			printf("interval is %d\n",ret);
+			sprintf(TmpBuf2,"%d",ret);
+			ezplib_replace_attr("pwatchdog_rule",0,"interval",TmpBuf2);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			ezplib_replace_attr("pwatchdog_rule",0,"interval",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pingwatchdogPingInterval\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get transfer protocol
+* it's only support tftp(0),ftp(1)
+* read-write
+*/
+int
+handle_pingwatchdogDelay(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char TmpBuf[Tmp_Len];
+	char TmpBuf2[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	memset(TmpBuf2,0,sizeof(TmpBuf2));
+	ezplib_get_attr_val("pwatchdog_rule", 0, "delay", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(TmpBuf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			ret = *(requests->requestvb->val.integer);
+			printf("delay is %d\n",ret);
+			if(ret > 3600 || ret < 60)//range is 60~3600 seconds
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			printf("delay is %d\n",ret);
+			sprintf(TmpBuf2,"%d",ret);
+			ezplib_replace_attr("pwatchdog_rule",0,"delay",TmpBuf2);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			ezplib_replace_attr("pwatchdog_rule",0,"delay",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pingwatchdogDelay\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set/get transfer protocol
+* it's only support tftp(0),ftp(1)
+* read-write
+*/
+int
+handle_pingwatchdogfailcount(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char TmpBuf[Tmp_Len];
+	char TmpBuf2[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	memset(TmpBuf2,0,sizeof(TmpBuf2));
+	ezplib_get_attr_val("pwatchdog_rule", 0, "failcount", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(TmpBuf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+				break;
+            }
+			ret = *(requests->requestvb->val.integer);
+			printf("failcount is %d\n",ret);
+			if(ret > 10 || ret < 1)//range is 1~10
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+            /* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			printf("failcount is %d\n",ret);
+			sprintf(TmpBuf2,"%d",ret);
+			ezplib_replace_attr("pwatchdog_rule",0,"failcount",TmpBuf2);
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+			ezplib_replace_attr("pwatchdog_rule",0,"failcount",TmpBuf);
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pingwatchdogfailcount\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*set upgrade firmware start
+* only '1' is valid
+* get operation is nonsense
+* read-write
+*/
+int
+handle_pingwatchdogRunStat(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    char enable[Tmp_Len],interval[Tmp_Len],ipaddr[Tmp_Len],delay[Tmp_Len],failcount[Tmp_Len];
+	char cmd[Tmp_Len],Tmp_buf[Tmp_Len];
+	memset(enable,0,sizeof(enable));
+	memset(ipaddr,0,sizeof(ipaddr));
+	memset(interval,0,sizeof(interval));
+	memset(delay,0,sizeof(delay));
+	memset(failcount,0,sizeof(failcount));
+	memset(cmd,0,sizeof(cmd));
+	memset(Tmp_buf,0,sizeof(Tmp_buf));
+
+	ezplib_get_attr_val("pwatchdog_rule", 0, "enable", Tmp_buf, Tmp_Len, EZPLIB_USE_CLI);
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+			ret=atoi(Tmp_buf);
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&ret,sizeof(ret));
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
+            }
+			ret = *(requests->requestvb->val.integer);
+			printf("RunStat is %d\n",ret);
+			if(ret != 0 && ret != 1)//1:run 0:stop
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
+			}
+            break;
+
+        case MODE_SET_RESERVE2:
+            /* XXX malloc "undo" storage buffer */
+            if (0) {
+                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+            }
+            break;
+
+        case MODE_SET_FREE:
+            /* XXX: free resources allocated in RESERVE1 and/or
+               RESERVE2.  Something failed somewhere, and the states
+               below won't be called. */
+            break;
+
+        case MODE_SET_ACTION:
+			/* XXX: perform the value change here */
+			ret = *(requests->requestvb->val.integer);
+			ezplib_get_attr_val("pwatchdog_rule", 0, "enable", enable, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("pwatchdog_rule", 0, "ip", ipaddr, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("pwatchdog_rule", 0, "interval", interval, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("pwatchdog_rule", 0, "delay", delay, Tmp_Len, EZPLIB_USE_CLI);
+			ezplib_get_attr_val("pwatchdog_rule", 0, "failcount", failcount, Tmp_Len, EZPLIB_USE_CLI);
+			sprintf(Tmp_buf,"%d",ret);
+			ezplib_replace_attr("pwatchdog_rule",0,"enable",Tmp_buf);
+			if(strlen(ipaddr) == 0)//no host to ping
+			{
+				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
+				break;
+			}
+			if(ret == 1)
+			{
+				if(atoi(enable) == 1)
+					sprintf(cmd,"pingwatchdog -s && pingwatchdog -i %d -d %d -f %d %s",atoi(interval),atoi(delay), atoi(failcount), ipaddr);
+				else
+					sprintf(cmd,"pingwatchdog -i %d -d %d -f %d %s",atoi(interval),atoi(delay), atoi(failcount), ipaddr);
+				system(cmd);
+			}else{
+				if(atoi(enable) == 1)
+					system("pingwatchdog -s");
+			}
+			
+            break;
+
+        case MODE_SET_COMMIT:
+            /* XXX: delete temporary storage */
+			nvram_commit();
+            break;
+
+        case MODE_SET_UNDO:
+            /* XXX: UNDO and return to previous value for the object */
+            //not need undo,otherwise,we cannot trace the fileoperation status
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwUpgradeAction\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+/*send upgrade status to server through v2trap
+* 1   success: the operation completed without error
+* 3   download fail: The operation required a valid fwUpgradeAddress or filname was not specified
+* 4   firmware invalid: the file operation was initiated, but failed during file transfer
+* 5   no space: the device did not have enough space to complete the operation
+*/
+int
+send_PingWatchdogStatus_trap( void )
+{
+    netsnmp_variable_list  *var_list = NULL;
+    const oid cpefileUpfwStatus_oid[] = { 1,3,6,1,4,1,50000,1,688,2,6 };
+
+	int ret;
+	char TmpBuf[Tmp_Len];
+	memset(TmpBuf,0,sizeof(TmpBuf));
+	ezplib_get_attr_val("pwatchdog_rule", 0, "enable", TmpBuf, Tmp_Len, EZPLIB_USE_CLI);
+    /*
+     * Set the snmpTrapOid.0 value
+     */
+    snmp_varlist_add_variable(&var_list,
+        snmptrap_oid, OID_LENGTH(snmptrap_oid),
+        ASN_OBJECT_ID,
+        cpefileUpfwStatus_oid, sizeof(cpefileUpfwStatus_oid));
+
+
+    /*
+     * Add any extra (optional) objects here
+     */
+     if(strlen(TmpBuf) > 0)
+     {
+     	ret = atoi(TmpBuf);
+     	snmp_varlist_add_variable(&var_list,
+            cpefileUpfwStatus_oid, OID_LENGTH(cpefileUpfwStatus_oid),
+            ASN_INTEGER,
+            (u_char *)&ret,
+            sizeof(ret));
+     }
+
+    /*
+     * Send the trap to the list of configured destinations
+     *  and clean up
+     */
+    send_v2trap( var_list );
+    snmp_free_varbind( var_list );
+
+    return SNMP_ERR_NOERROR;
+}
diff -Nur net-snmp-5.4.2.1/agent/mibgroup_old/CPEPingWatchdogModule.h net-snmp-5.4.2.1/agent/mibgroup/CPEPingWatchdogModule.h
--- net-snmp-5.4.2.1/agent/mibgroup_old/CPEPingWatchdogModule.h	1970-01-01 08:00:00.000000000 +0800
+++ net-snmp-5.4.2.1/agent/mibgroup/CPEPingWatchdogModule.h	2013-07-25 17:59:07.997302398 +0800
@@ -0,0 +1,35 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf 17798 2009-10-27 06:44:54Z magfr $
+ * Author:Alvin ke
+ * revision: initial
+ * maily for setting parameters of ping watchdog through snmp
+ * date: 2013-7-25
+ */
+#ifndef CPEPINGWATCHDOGMODULE_H
+#define CPEPINGWATCHDOGMODULE_H
+
+#include "ezp-lib.h"
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/reboot.h>
+
+#define Tmp_Len 128
+
+/* function declarations */
+void init_CPEPingWatchdogModule(void);
+int send_PingWatchdogStatus_trap(void);
+Netsnmp_Node_Handler handle_pingwatchdogRunStat;
+Netsnmp_Node_Handler handle_pingwatchdogPingAddress;
+Netsnmp_Node_Handler handle_pingwatchdogPingInterval;
+Netsnmp_Node_Handler handle_pingwatchdogDelay;
+Netsnmp_Node_Handler handle_pingwatchdogfailcount;
+
+#endif /* CPEUPFIRMWAREMODULE_H */
+
+
