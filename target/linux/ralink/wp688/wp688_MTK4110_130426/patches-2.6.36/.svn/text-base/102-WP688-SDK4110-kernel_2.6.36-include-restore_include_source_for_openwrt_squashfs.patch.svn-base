diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/decompress/bunzip2_mm.h linux-2.6.36/include/linux/decompress/bunzip2_mm.h
--- linux-2.6.36_builded_sdk_orig/include/linux/decompress/bunzip2_mm.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/decompress/bunzip2_mm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
-#ifndef BUNZIP2_MM_H
-#define BUNZIP2_MM_H
-
-#ifdef STATIC
-/* Code active when included from pre-boot environment: */
-#define INIT
-#else
-/* Compile for initramfs/initrd code only */
-#define INIT __init
-static void(*error)(char *m);
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/decompress/inflate_mm.h linux-2.6.36/include/linux/decompress/inflate_mm.h
--- linux-2.6.36_builded_sdk_orig/include/linux/decompress/inflate_mm.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/decompress/inflate_mm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
-#ifndef INFLATE_MM_H
-#define INFLATE_MM_H
-
-#ifdef STATIC
-/* Code active when included from pre-boot environment: */
-#define INIT
-#else
-/* Compile for initramfs/initrd code only */
-#define INIT __init
-static void(*error)(char *m);
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/decompress/mm.h linux-2.6.36/include/linux/decompress/mm.h
--- linux-2.6.36_builded_sdk_orig/include/linux/decompress/mm.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/decompress/mm.h	2010-10-21 04:30:22.000000000 +0800
@@ -63,6 +63,8 @@
 
 #define set_error_fn(x)
 
+#define INIT
+
 #else /* STATIC */
 
 /* Code active when compiled standalone for use when loading ramdisk: */
@@ -82,8 +84,10 @@
 #define large_malloc(a) vmalloc(a)
 #define large_free(a) vfree(a)
 
+static void(*error)(char *m);
 #define set_error_fn(x) error = x;
 
+#define INIT __init
 #define STATIC
 
 #include <linux/init.h>
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/decompress/unlzma_mm.h linux-2.6.36/include/linux/decompress/unlzma_mm.h
--- linux-2.6.36_builded_sdk_orig/include/linux/decompress/unlzma_mm.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/decompress/unlzma_mm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,20 +0,0 @@
-#ifndef UNLZMA_MM_H
-#define UNLZMA_MM_H
-
-#ifdef STATIC
-
-/* Code active when included from pre-boot environment: */
-#define INIT
-
-#elif defined(CONFIG_DECOMPRESS_LZMA_NEEDED)
-
-/* Make it available to non initramfs/initrd code */
-#define INIT
-#include <linux/module.h>
-#else
-
-/* Compile for initramfs/initrd code only */
-#define INIT __init
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/decompress/unlzo_mm.h linux-2.6.36/include/linux/decompress/unlzo_mm.h
--- linux-2.6.36_builded_sdk_orig/include/linux/decompress/unlzo_mm.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/decompress/unlzo_mm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
-#ifndef UNLZO_MM_H
-#define UNLZO_MM_H
-
-#ifdef STATIC
-/* Code active when included from pre-boot environment: */
-#define INIT
-#else
-/* Compile for initramfs/initrd code only */
-#define INIT __init
-static void(*error)(char *m);
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/jffs2.h linux-2.6.36/include/linux/jffs2.h
--- linux-2.6.36_builded_sdk_orig/include/linux/jffs2.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/jffs2.h	2010-10-21 04:30:22.000000000 +0800
@@ -46,7 +46,6 @@
 #define JFFS2_COMPR_DYNRUBIN	0x05
 #define JFFS2_COMPR_ZLIB	0x06
 #define JFFS2_COMPR_LZO		0x07
-#define JFFS2_COMPR_LZMA	0x08
 /* Compatibility flags. */
 #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
 #define JFFS2_NODE_ACCURATE 0x2000
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzFind.h linux-2.6.36/include/linux/lzma/LzFind.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzFind.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma/LzFind.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,115 +0,0 @@
-/* LzFind.h -- Match finder for LZ algorithms
-2009-04-22 : Igor Pavlov : Public domain */
-
-#ifndef __LZ_FIND_H
-#define __LZ_FIND_H
-
-#include "Types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef UInt32 CLzRef;
-
-typedef struct _CMatchFinder
-{
-  Byte *buffer;
-  UInt32 pos;
-  UInt32 posLimit;
-  UInt32 streamPos;
-  UInt32 lenLimit;
-
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-
-  UInt32 matchMaxLen;
-  CLzRef *hash;
-  CLzRef *son;
-  UInt32 hashMask;
-  UInt32 cutValue;
-
-  Byte *bufferBase;
-  ISeqInStream *stream;
-  int streamEndWasReached;
-
-  UInt32 blockSize;
-  UInt32 keepSizeBefore;
-  UInt32 keepSizeAfter;
-
-  UInt32 numHashBytes;
-  int directInput;
-  size_t directInputRem;
-  int btMode;
-  int bigHash;
-  UInt32 historySize;
-  UInt32 fixedHashSize;
-  UInt32 hashSizeSum;
-  UInt32 numSons;
-  SRes result;
-  UInt32 crc[256];
-} CMatchFinder;
-
-#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
-#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
-
-#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
-
-int MatchFinder_NeedMove(CMatchFinder *p);
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-void MatchFinder_MoveBlock(CMatchFinder *p);
-void MatchFinder_ReadIfRequired(CMatchFinder *p);
-
-void MatchFinder_Construct(CMatchFinder *p);
-
-/* Conditions:
-     historySize <= 3 GB
-     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
-*/
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc);
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *distances, UInt32 maxLen);
-
-/*
-Conditions:
-  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-*/
-
-typedef void (*Mf_Init_Func)(void *object);
-typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
-typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-typedef void (*Mf_Skip_Func)(void *object, UInt32);
-
-typedef struct _IMatchFinder
-{
-  Mf_Init_Func Init;
-  Mf_GetIndexByte_Func GetIndexByte;
-  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-  Mf_GetMatches_Func GetMatches;
-  Mf_Skip_Func Skip;
-} IMatchFinder;
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-
-void MatchFinder_Init(CMatchFinder *p);
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzHash.h linux-2.6.36/include/linux/lzma/LzHash.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzHash.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma/LzHash.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,54 +0,0 @@
-/* LzHash.h -- HASH functions for LZ algorithms
-2009-02-07 : Igor Pavlov : Public domain */
-
-#ifndef __LZ_HASH_H
-#define __LZ_HASH_H
-
-#define kHash2Size (1 << 10)
-#define kHash3Size (1 << 16)
-#define kHash4Size (1 << 20)
-
-#define kFix3HashSize (kHash2Size)
-#define kFix4HashSize (kHash2Size + kHash3Size)
-#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-
-#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
-
-#define HASH3_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp & (kHash2Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
-
-#define HASH4_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp & (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
-
-#define HASH5_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp & (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
-  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
-  hash4Value &= (kHash4Size - 1); }
-
-/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
-#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
-
-
-#define MT_HASH2_CALC \
-  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
-
-#define MT_HASH3_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp & (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
-
-#define MT_HASH4_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  hash2Value = temp & (kHash2Size - 1); \
-  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
-  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzmaDec.h linux-2.6.36/include/linux/lzma/LzmaDec.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzmaDec.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma/LzmaDec.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,231 +0,0 @@
-/* LzmaDec.h -- LZMA Decoder
-2009-02-07 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA_DEC_H
-#define __LZMA_DEC_H
-
-#include "Types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* #define _LZMA_PROB32 */
-/* _LZMA_PROB32 can increase the speed on some CPUs,
-   but memory usage for CLzmaDec::probs will be doubled in that case */
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-
-/* ---------- LZMA Properties ---------- */
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaProps
-{
-  unsigned lc, lp, pb;
-  UInt32 dicSize;
-} CLzmaProps;
-
-/* LzmaProps_Decode - decodes properties
-Returns:
-  SZ_OK
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-
-
-/* ---------- LZMA Decoder state ---------- */
-
-/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
-
-#define LZMA_REQUIRED_INPUT_MAX 20
-
-typedef struct
-{
-  CLzmaProps prop;
-  CLzmaProb *probs;
-  Byte *dic;
-  const Byte *buf;
-  UInt32 range, code;
-  SizeT dicPos;
-  SizeT dicBufSize;
-  UInt32 processedPos;
-  UInt32 checkDicSize;
-  unsigned state;
-  UInt32 reps[4];
-  unsigned remainLen;
-  int needFlush;
-  int needInitState;
-  UInt32 numProbs;
-  unsigned tempBufSize;
-  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-} CLzmaDec;
-
-#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
-
-void LzmaDec_Init(CLzmaDec *p);
-
-/* There are two types of LZMA streams:
-     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-
-typedef enum
-{
-  LZMA_FINISH_ANY,   /* finish at any point */
-  LZMA_FINISH_END    /* block must be finished at the end */
-} ELzmaFinishMode;
-
-/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-
-   You must use LZMA_FINISH_END, when you know that current output buffer
-   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-
-   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-   and output value of destLen will be less than output buffer size limit.
-   You can check status result also.
-
-   You can use multiple checks to test data integrity after full decompression:
-     1) Check Result and "status" variable.
-     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-        You must use correct finish mode in that case. */
-
-typedef enum
-{
-  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-} ELzmaStatus;
-
-/* ELzmaStatus is used only as output value for function call */
-
-
-/* ---------- Interfaces ---------- */
-
-/* There are 3 levels of interfaces:
-     1) Dictionary Interface
-     2) Buffer Interface
-     3) One Call Interface
-   You can select any of these interfaces, but don't mix functions from different
-   groups for same object. */
-
-
-/* There are two variants to allocate state for Dictionary Interface:
-     1) LzmaDec_Allocate / LzmaDec_Free
-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-   You can use variant 2, if you set dictionary buffer manually.
-   For Buffer Interface you must always use variant 1.
-
-LzmaDec_Allocate* can return:
-  SZ_OK
-  SZ_ERROR_MEM         - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-   
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-
-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-
-/* ---------- Dictionary Interface ---------- */
-
-/* You can use it, if you want to eliminate the overhead for data copying from
-   dictionary to some other external buffer.
-   You must work with CLzmaDec variables directly in this interface.
-
-   STEPS:
-     LzmaDec_Constr()
-     LzmaDec_Allocate()
-     for (each new stream)
-     {
-       LzmaDec_Init()
-       while (it needs more decompression)
-       {
-         LzmaDec_DecodeToDic()
-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-       }
-     }
-     LzmaDec_Free()
-*/
-
-/* LzmaDec_DecodeToDic
-   
-   The decoding to internal dictionary buffer (CLzmaDec::dic).
-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (dicLimit).
-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-  LZMA_FINISH_END - Stream must be finished after dicLimit.
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_NEEDS_MORE_INPUT
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-*/
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- Buffer Interface ---------- */
-
-/* It's zlib-like interface.
-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-   to work with CLzmaDec variables manually.
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-*/
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaDecode
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-  SZ_ERROR_MEM  - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-*/
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzmaEnc.h linux-2.6.36/include/linux/lzma/LzmaEnc.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma/LzmaEnc.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma/LzmaEnc.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
-/*  LzmaEnc.h -- LZMA Encoder
-2009-02-07 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA_ENC_H
-#define __LZMA_ENC_H
-
-#include "Types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaEncProps
-{
-  int level;       /*  0 <= level <= 9 */
-  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
-                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
-                       default = (1 << 24) */
-  int lc;          /* 0 <= lc <= 8, default = 3 */
-  int lp;          /* 0 <= lp <= 4, default = 0 */
-  int pb;          /* 0 <= pb <= 4, default = 2 */
-  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-  int fb;          /* 5 <= fb <= 273, default = 32 */
-  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-  int numHashBytes; /* 2, 3 or 4, default = 4 */
-  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
-  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-  int numThreads;  /* 1 or 2, default = 2 */
-} CLzmaEncProps;
-
-void LzmaEncProps_Init(CLzmaEncProps *p);
-void LzmaEncProps_Normalize(CLzmaEncProps *p);
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-
-
-/* ---------- CLzmaEncHandle Interface ---------- */
-
-/* LzmaEnc_* functions can return the following exit codes:
-Returns:
-  SZ_OK           - OK
-  SZ_ERROR_MEM    - Memory allocation error
-  SZ_ERROR_PARAM  - Incorrect paramater in props
-  SZ_ERROR_WRITE  - Write callback error.
-  SZ_ERROR_PROGRESS - some break from progress callback
-  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-*/
-
-typedef void * CLzmaEncHandle;
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaEncode
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma/Types.h linux-2.6.36/include/linux/lzma/Types.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma/Types.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma/Types.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,226 +0,0 @@
-/* Types.h -- Basic types
-2009-11-23 : Igor Pavlov : Public domain */
-
-#ifndef __7Z_TYPES_H
-#define __7Z_TYPES_H
-
-#include <stddef.h>
-
-#ifdef _WIN32
-#include <windows.h>
-#endif
-
-#ifndef EXTERN_C_BEGIN
-#ifdef __cplusplus
-#define EXTERN_C_BEGIN extern "C" {
-#define EXTERN_C_END }
-#else
-#define EXTERN_C_BEGIN
-#define EXTERN_C_END
-#endif
-#endif
-
-EXTERN_C_BEGIN
-
-#define SZ_OK 0
-
-#define SZ_ERROR_DATA 1
-#define SZ_ERROR_MEM 2
-#define SZ_ERROR_CRC 3
-#define SZ_ERROR_UNSUPPORTED 4
-#define SZ_ERROR_PARAM 5
-#define SZ_ERROR_INPUT_EOF 6
-#define SZ_ERROR_OUTPUT_EOF 7
-#define SZ_ERROR_READ 8
-#define SZ_ERROR_WRITE 9
-#define SZ_ERROR_PROGRESS 10
-#define SZ_ERROR_FAIL 11
-#define SZ_ERROR_THREAD 12
-
-#define SZ_ERROR_ARCHIVE 16
-#define SZ_ERROR_NO_ARCHIVE 17
-
-typedef int SRes;
-
-#ifdef _WIN32
-typedef DWORD WRes;
-#else
-typedef int WRes;
-#endif
-
-#ifndef RINOK
-#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-#endif
-
-typedef unsigned char Byte;
-typedef short Int16;
-typedef unsigned short UInt16;
-
-#ifdef _LZMA_UINT32_IS_ULONG
-typedef long Int32;
-typedef unsigned long UInt32;
-#else
-typedef int Int32;
-typedef unsigned int UInt32;
-#endif
-
-#ifdef _SZ_NO_INT_64
-
-/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
-   NOTES: Some code will work incorrectly in that case! */
-
-typedef long Int64;
-typedef unsigned long UInt64;
-
-#else
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef __int64 Int64;
-typedef unsigned __int64 UInt64;
-#else
-typedef long long int Int64;
-typedef unsigned long long int UInt64;
-#endif
-
-#endif
-
-#ifdef _LZMA_NO_SYSTEM_SIZE_T
-typedef UInt32 SizeT;
-#else
-typedef size_t SizeT;
-#endif
-
-typedef int Bool;
-#define True 1
-#define False 0
-
-
-#ifdef _WIN32
-#define MY_STD_CALL __stdcall
-#else
-#define MY_STD_CALL
-#endif
-
-#ifdef _MSC_VER
-
-#if _MSC_VER >= 1300
-#define MY_NO_INLINE __declspec(noinline)
-#else
-#define MY_NO_INLINE
-#endif
-
-#define MY_CDECL __cdecl
-#define MY_FAST_CALL __fastcall
-
-#else
-
-#define MY_CDECL
-#define MY_FAST_CALL
-
-#endif
-
-
-/* The following interfaces use first parameter as pointer to structure */
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-       (output(*size) < input(*size)) is allowed */
-} ISeqInStream;
-
-/* it can return SZ_ERROR_INPUT_EOF */
-SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-
-typedef struct
-{
-  size_t (*Write)(void *p, const void *buf, size_t size);
-    /* Returns: result - the number of actually written bytes.
-       (result < size) means error */
-} ISeqOutStream;
-
-typedef enum
-{
-  SZ_SEEK_SET = 0,
-  SZ_SEEK_CUR = 1,
-  SZ_SEEK_END = 2
-} ESzSeek;
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ISeekInStream;
-
-typedef struct
-{
-  SRes (*Look)(void *p, void **buf, size_t *size);
-    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-       (output(*size) > input(*size)) is not allowed
-       (output(*size) < input(*size)) is allowed */
-  SRes (*Skip)(void *p, size_t offset);
-    /* offset must be <= output(*size) of Look */
-
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ILookInStream;
-
-SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-
-/* reads via ILookInStream::Read */
-SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-
-#define LookToRead_BUF_SIZE (1 << 14)
-
-typedef struct
-{
-  ILookInStream s;
-  ISeekInStream *realStream;
-  size_t pos;
-  size_t size;
-  Byte buf[LookToRead_BUF_SIZE];
-} CLookToRead;
-
-void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-void LookToRead_Init(CLookToRead *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToLook;
-
-void SecToLook_CreateVTable(CSecToLook *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToRead;
-
-void SecToRead_CreateVTable(CSecToRead *p);
-
-typedef struct
-{
-  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-    /* Returns: result. (result != SZ_OK) means break.
-       Value (UInt64)(Int64)-1 for size means unknown value. */
-} ICompressProgress;
-
-typedef struct
-{
-  void *(*Alloc)(void *p, size_t size);
-  void (*Free)(void *p, void *address); /* address can be 0 */
-} ISzAlloc;
-
-#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
-#define IAlloc_Free(p, a) (p)->Free((p), a)
-
-EXTERN_C_END
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/linux/lzma.h linux-2.6.36/include/linux/lzma.h
--- linux-2.6.36_builded_sdk_orig/include/linux/lzma.h	2012-12-10 16:31:47.000000000 +0800
+++ linux-2.6.36/include/linux/lzma.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-#ifndef __LZMA_H__
-#define __LZMA_H__
-
-#ifdef __KERNEL__
-	#include <linux/kernel.h>
-	#include <linux/sched.h>
-	#include <linux/slab.h>
-	#include <linux/vmalloc.h>
-	#include <linux/init.h>
-	#define LZMA_MALLOC vmalloc
-	#define LZMA_FREE vfree
-	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
-	#define INIT __init
-	#define STATIC static
-#else
-	#include <stdint.h>
-	#include <stdlib.h>
-	#include <stdio.h>
-	#include <unistd.h>
-	#include <string.h>
-	#include <asm/types.h>
-	#include <errno.h>
-	#include <linux/jffs2.h>
-	#ifndef PAGE_SIZE
-		extern int page_size;
-		#define PAGE_SIZE page_size
-	#endif
-	#define LZMA_MALLOC malloc
-	#define LZMA_FREE free
-	#define PRINT_ERROR(msg) fprintf(stderr, msg)
-	#define INIT
-	#define STATIC
-#endif
-
-#include "lzma/LzmaDec.h"
-#include "lzma/LzmaEnc.h"
-
-#define LZMA_BEST_LEVEL (9)
-#define LZMA_BEST_LC    (0)
-#define LZMA_BEST_LP    (0)
-#define LZMA_BEST_PB    (0)
-#define LZMA_BEST_FB  (273)
-
-#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
-
-static void *p_lzma_malloc(void *p, size_t size)
-{
-        if (size == 0)
-                return NULL;
-
-        return LZMA_MALLOC(size);
-}
-
-static void p_lzma_free(void *p, void *address)
-{
-        if (address != NULL)
-                LZMA_FREE(address);
-}
-
-static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
-
-#endif
diff -Nur linux-2.6.36_builded_sdk_orig/include/net/gre.h linux-2.6.36/include/net/gre.h
--- linux-2.6.36_builded_sdk_orig/include/net/gre.h	2012-12-10 16:31:46.000000000 +0800
+++ linux-2.6.36/include/net/gre.h	2012-08-28 16:06:38.000000000 +0800
@@ -12,7 +12,7 @@
 	void	(*err_handler)(struct sk_buff *skb, u32 info);
 };
 
-int gre_add_protocol(const struct gre_protocol *proto, u8 version);
-int gre_del_protocol(const struct gre_protocol *proto, u8 version);
+extern int gre_add_protocol(const struct gre_protocol *proto, u8 version);
+extern int gre_del_protocol(const struct gre_protocol *proto, u8 version);
 
 #endif
